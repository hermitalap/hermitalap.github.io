[{"categories":["杂谈"],"content":"前言 最近实验室出现大量U盘感染事件，不少师兄师姐珍贵的实验数据灰飞烟灭，因为显微镜室的电脑并未联网，所需每次进行镜检后使用U盘拷贝是必须的步骤。加上显微镜室的电脑还有其他实验室的在使用，众多使用者的U盘很容易出现交叉感染的情况。 现将本人收集的除了安装杀毒软件以外的U盘防毒方法整理如下 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:0","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["杂谈"],"content":"使用带有写保护功能的U盘 病毒植入U盘必然伴随着写入，带有硬件写保护功能的U盘能够有效防御学校打印店，公共演示电脑上带有的病毒。可以说是目前唯一能够100%防御病毒的方法，缺点是但是款式较少，且主要面向商务用户，价格较高。且不适用于需要向U盘内拷贝文件的场合。 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:1","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["杂谈"],"content":"关闭自动播放功能 部分U盘病毒的传播方法是伪造autorun.inf文件，该文件定义了硬件被接入电脑后会以何种方式自动运行哪个程序，打开自动播放可能会导致病毒程序被系统自动运行。 以win10为例，依次打开设置-\u003e设备-\u003e自动播放-\u003e关闭自动播放 设置-\u003e设备-\u003e自动播放-\u003e关闭自动播放\" 设置-设备-自动播放-关闭自动播放 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:2","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["杂谈"],"content":"构建不可修改的autorun.inf 即便是关闭了自动播放，在资源管理器双击U盘图标时，系统也会按照autorun.inf中的指示自动运行病毒程序，所以安全的做法是右键U盘图标然后点击“打开”，并注意是否有可疑的自动播放选项。考虑到使用个人U盘的过程中很少会用到autorun.inf，所以我们可以创建一个不可被病毒程序修改的“autorun.inf”来抵御所有依赖这种传播方式的病毒。 我在网上看到有人说，“既然病毒需要使用autorun.inf，那我们预先创建一个autorun.inf，病毒就无法传播了”，这完全是来搞笑的，凭什么你会觉得病毒不会覆盖或者删除原有的antorun.inf文件？不过这个馊主意也给了我一些灵感，经过尝试和使用一些骚操作，我还是实现对autorun.inf的被动防御。 这里主要运用了两种机制 windows下，同一目录下不可出现相同名称的文件和文件夹 如果目录下存在畸形目录，那么父目录不可被删除。 首先在U盘根目录下创建“autorun.inf”文件夹，当这个文件夹存在的时候，病毒就无法创建“autorun.inf”文件了 windows下，同一目录下不可出现相同名称的文件和文件夹\" windows下，同一目录下不可出现相同名称的文件和文件夹 但是病毒可能会删除这个文件夹，所以我们要让这个文件夹不可被删除。 首先进入“autorun.inf”文件夹，右键，点击“在终端/cmd中打开”，你也可以说win+r，输入cmd后回车，然后手动cd到U盘的这个目录下。然后 D:\\autorun.inf\u003emd imzifeng.cn..\\ 在该目录下创建一个文件夹，在任意名称的后面跟上两个或多个点（.）,这种带有两个或多个点的目录就是一个畸形目录，它无法通过常规方法删除 常规删除方法\" 常规删除方法 无法删除\" 无法删除 同样的，由于它是“autorun.inf”目录的子目录，导致“autorun.inf”也无法正常删除和访问。 无法删除的autorun.inf\" 无法删除的autorun.inf 这样就构建了一个不可删除的“autorun.inf”目录 如果之后需要删除，可以在终端中输入 D:\\autorun.inf\u003erd imzifeng.cn..\\ 需要注意的是，这个方法只能阻止利用了autorun.inf文件的病毒，现在很多病毒都比较高级，比如把U盘下的文件全部隐藏，然后复刻一个一摸一样的目录，不过把所有文件以及文件夹都替换为exe可执行文件，一点就中招，不过我一般都是开启了显示隐藏文件以及显示文件扩展名。 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:3","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["杂谈"],"content":"各类U盘保险箱程序 治标不治本，还有可能导致重要文件团灭。 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:4","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["杂谈"],"content":"反正不是我的电脑 拷贝几个杀毒软件的安装包，遇到没有安装杀毒软件的可疑电脑，就给他安排上，然后拔U盘前把U盘查杀一遍。不过这年头，电脑上有好几个杀毒软件炼蛊的一定是小白，但是一个杀毒软件都没装的也可能是高手，所以做好被打的准备。不过装火绒可能被打得轻一点。 ","date":"2021-09-04","objectID":"/posts/usbflashdiskantivirus/:1:5","series":[],"tags":[],"title":"U盘不完全防毒","uri":"/posts/usbflashdiskantivirus/"},{"categories":["Doc"],"content":"Git 是一个分布式版本控制系统. 文本，脚本，以及各种基于文本信息的文件可被Git管理 各软件私有格式、二进制文件、媒体不可被Git管理 ","date":"2021-09-01","objectID":"/posts/git/:0:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"安装 官方下载地址，Git ","date":"2021-09-01","objectID":"/posts/git/:1:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"GUI管理器 GitHub Desktop Sourcetree ","date":"2021-09-01","objectID":"/posts/git/:1:1","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"基本使用 ","date":"2021-09-01","objectID":"/posts/git/:2:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"基本配置 设置个人信息，用于将修改与人对应 $ git config --global user.name \"username\" $ git config --global user.email \"email@example.com\" ","date":"2021-09-01","objectID":"/posts/git/:2:1","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(init）创建版本库 Repository 首先cd到你要管理的文件夹 然后创建 git init # Initialized empty Git repository in somefoloers/.git/ # 提示：使用 'master' 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中 # 提示：配置使用初始分支名，并消除这条警告，请执行： # 提示： # 提示： git config --global init.defaultBranch \u003c名称\u003e # 提示： # 提示：除了 'master' 之外，通常选定的名字有 'main'、'trunk' 和 'development'。 # 提示：可以通过以下命令重命名刚创建的分支： # 提示： # 提示： git branch -m \u003cname\u003e git 创建的管理库文件 .git 是被隐藏起来的 ","date":"2021-09-01","objectID":"/posts/git/:2:2","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(add）添加文件管理 建立一个新的 1.py 文件: $ touch first.py 现在 first.py 并没有被放入版本库中 (unstaged), 所以我们要使用 add 把它添加进版本库 (staged): $ git add first.py # 再次查看状态 status $ git status 位于分支 master 尚无提交 要提交的变更： （使用 \"git rm --cached \u003c文件\u003e...\" 以取消暂存） 新文件： first.py 如果想一次性添加文件夹中所有未被添加的文件, 可以使用这个: $ git add . ","date":"2021-09-01","objectID":"/posts/git/:2:3","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(commit）提交改变 我们已经添加好了 first.py 文件, 最后一步就是提交这次的改变, 并在 -m 自定义这次改变的信息: $ git commit -m \"create first.py\" # 输出 [master（根提交） d722a66] create first.py 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 first.py $ git commit -am \"change 3 in dev\" # \"-am\": add 所有改变 并直接 commit ","date":"2021-09-01","objectID":"/posts/git/:2:4","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(log）修改记录 查看 $ git log # 输出 commit d722a6689063eebd44a4584c07c7bf613520b5d5 (HEAD -\u003e master) Author: xxx \u003cxxx@126.com\u003e Date: Mon Aug 30 21:38:36 2021 +0800 create first.py $ git log --oneline # \"--oneline\": 每个 commit 内容显示在一行,更简洁，不显示时间 9aeb5f1 (HEAD -\u003e master) create second.py d722a66 create first.py ","date":"2021-09-01","objectID":"/posts/git/:2:5","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(diff）查看 unstaged 如果想要查看这次还没 add (unstaged) 的修改部分 和上个已经 commit 的文件有何不同, 我们将使用 $ git diff: $ git diff # 输出 diff --git a/first.py b/first.py index e69de29..1337a53 100644 --- a/first.py +++ b/first.py @@ -0,0 +1 @@ +a = 1 注意这里不会显示你还没有追踪的文件，也就是还没有add的文件修改并不会被显示 ","date":"2021-09-01","objectID":"/posts/git/:2:6","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(diff –cached）查看 staged 如果你已经 add 了这次修改, 文件变成了 “可提交状态 (staged)”, 我们可以在 diff 中添加参数 --cached 来查看修改: $ git add . # add 全部修改文件 $ git diff --cached # 输出 diff --git a/1.py b/1.py index 1337a53..ff7c36c 100644 --- a/1.py +++ b/1.py @@ -1 +1,2 @@ -a = 1 +a = 2 +b = 1 ","date":"2021-09-01","objectID":"/posts/git/:2:7","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(diff HEAD）查看 staged \u0026 unstaged 显示所有的修改，不管是否为staged（已add）或unstaged（未add） 目前 a = 2 和 b = 1 已被 add, c = b 是新的修改, 还没被 add. # 对比三种不同 diff 形式 $ git diff HEAD # staged \u0026 unstaged @@ -1 +1,3 @@ -a = 1 # 已 staged +a = 2 # 已 staged +b = 1 # 已 staged +c = b # 还没 add 去 stage (unstaged) ----------------------- $ git diff # unstaged @@ -1,2 +1,3 @@ a = 2 # 注: 前面没有 + b = 1 # 注: 前面没有 + +c = b # 还没 add 去 stage (unstaged) ----------------------- $ git diff --cached # staged @@ -1 +1,2 @@ -a = 1 # 已 staged +a = 2 # 已 staged +b = 1 # 已 staged ","date":"2021-09-01","objectID":"/posts/git/:2:8","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(commit –amend）修改已 commit 的版本 有时候我们总会忘了什么, 比如已经提交了 commit 却发现在这个 commit 中忘了附上另一个文件. 接下来我们模拟这种情况. 上节内容中, 我们最后一个 commit 是 change 2, 我们将要添加另外一个文件, 将这个修改也 commit 进 change 2. 所以我们复制 1.py 这个文件, 改名为 2.py. 并把 2.py 变成 staged, 然后使用 --amend 将这次改变合并到之前的 change 2 中. $ git add 2.py $ git commit --amend --no-edit # \"--no-edit\": 不编辑, 直接合并到上一个 commit $ git log --oneline # \"--oneline\": 每个 commit 内容显示在一行 # 输出 904e1ba change 2 # 合并过的 change 2 c6762a1 change 1 13be9a7 create 1.py ","date":"2021-09-01","objectID":"/posts/git/:2:9","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(reset）回到unstaged状态 有时我们添加 add 了修改, 但是又后悔, 并想补充一些内容再 add. 这时, 我们有一种方式可以回到 add 之前. 比如在 1.py 文件中添加这一行: d = 3 然后 add 去 staged 再返回到 add 之前: $ git add 1.py $ git status -s # \"-s\": status 的缩写模式 # 输出 M 1.py # staged，绿色M ----------------------- $ git reset 1.py # 输出 重置后取消暂存的变更： M 1.py ----------------------- $ git status -s # 输出 M 1.py # unstaged，红色M ","date":"2021-09-01","objectID":"/posts/git/:2:10","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(reset –hard xxxxxx）回到 commit 之前 在穿梭到过去的 commit 之前, 我们必须了解 git 是如何一步一步累加更改的. 我们截取网上的一些图片 \" \" \" \" 每个 commit 都有自己的 id 数字号, HEAD 是一个指针, 指引当前的状态是在哪个 commit. 最近的一次 commit 在最右边, 我们如果要回到过去, 就是让 HEAD 回到过去并 reset 此时的 HEAD 到过去的位置. # 不管我们之前有没有做了一些 add 工作, 这一步让我们回到 上一次的 commit $ git reset --hard HEAD # 输出 HEAD is now at 904e1ba change 2 ----------------------- # 看看所有的log $ git log --oneline # 输出 904e1ba change 2 c6762a1 change 1 13be9a7 create 1.py ----------------------- # 回到 c6762a1 change 1 # 方式1: \"HEAD^\" $ git reset --hard HEAD^ # 方式2: \"commit id\" $ git reset --hard c6762a1 ----------------------- # 看看现在的 log $ git log --oneline # 输出 c6762a1 change 1 13be9a7 create 1.py 此时回到了change 1, 在此之后的修改都消失了，我们可以查看 $ git reflog 里面最近做的所有 HEAD 的改动, 并选择想要回到的 commit id: $ git reflog # 输出 c6762a1 HEAD@{0}: reset: moving to c6762a1 904e1ba HEAD@{1}: commit (amend): change 2 0107760 HEAD@{2}: commit: change 2 c6762a1 HEAD@{3}: commit: change 1 13be9a7 HEAD@{4}: commit (initial): create 1.py 重复 reset 步骤就能回到 commit (amend): change 2 (id=904e1ba)这一步了: $ git reset --hard 904e1ba $ git log --oneline # 输出 904e1ba change 2 c6762a1 change 1 13be9a7 create 1.py 我们又再次回到了 change 2. ","date":"2021-09-01","objectID":"/posts/git/:2:11","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(checkout）改写文件 其实 checkout 最主要的用途并不是让单个文件回到过去, 我们之后会继续讲 checkout 在分支 branch 中的应用, 这一节主要讲 checkout 让文件回到过去. 我们现在的版本库中有两个文件: - gitTUT - 1.py - 2.py 我们仅仅要对 1.py 进行回到过去操作, 回到 c6762a1 change 1 这一个 commit. 使用 checkout + id c6762a1 + -- + 文件目录 1.py, 我们就能将 1.py 的指针 HEAD 放在这个时刻 c6762a1: $ git log --oneline # 输出 904e1ba change 2 c6762a1 change 1 13be9a7 create 1.py --------------------- $ git checkout c6762a1 -- 1.py 这时 1.py 文件的内容就变成了: a = 1 我们在 1.py 加上一行内容 # I went back to change 1 然后 add 并 commit 1.py: $ git add 1.py $ git commit -m \"back to change 1 and add comment for 1.py\" $ git log --oneline # 输出 47f167e back to change 1 and add comment for 1.py 904e1ba change 2 c6762a1 change 1 13be9a7 create 1.py 可以看出, 不像 reset 时那样, 我们的 change 2 并没有消失, 但是 1.py 却已经回去了过去, 并改写了未来. ","date":"2021-09-01","objectID":"/posts/git/:2:12","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"分支管理 ","date":"2021-09-01","objectID":"/posts/git/:3:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(branch dev）使用branch创建分支 我们建立另一个分支 dev, 并查看所有分支: $ git branch dev # 建立 dev 分支 $ git branch # 查看当前分支 # 输出 dev * master # * 代表了当前的 HEAD 所在的分支 当我们想把 HEAD 切换去 dev 分支的时候, 我们可以用到上次说的 checkout: $ git checkout dev # 输出 Switched to branch 'dev' ","date":"2021-09-01","objectID":"/posts/git/:3:1","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(log –oneline –graph）使用graph观看分支 $ git branch # 输出 * dev # 这时 HEAD 已经被切换至 dev 分支 master $ git log --oneline --graph # 输出 * 9f3367b (HEAD -\u003e dev) create dev branch * 9aeb5f1 (master) create second.py * d722a66 create first.py ","date":"2021-09-01","objectID":"/posts/git/:3:2","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(checkout -b）直接创建并切换到新建的分支 使用 checkout -b + 分支名, 就能直接创建和切换到新建的分支: $ git checkout -b dev # 输出 Switched to a new branch 'dev' -------------------------- $ git branch # 输出 * dev # 这时 HEAD 已经被切换至 dev 分支 master ","date":"2021-09-01","objectID":"/posts/git/:3:3","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(merge）将 dev 的修改推送到 master 们 dev 中的修改推送到 master 中，首先要切换到 master, 再将 dev 推送过来. $ git checkout master # 切换至 master 才能把其他分支合并过来 $ git merge dev # 将 dev merge 到 master 中 $ git log --oneline --graph # 输出 * f9584f8 change 3 in dev * 47f167e back to change 1 and add comment for 1.py * 904e1ba change 2 * c6762a1 change 1 * 13be9a7 create 1.py 要注意的是, 如果直接 git merge dev, git 会采用默认的 Fast forward 格式进行 merge, 这样 merge 的这次操作不会有 commit 信息. log 中也不会有分支的图案. 我们可以采取 --no-ff 这种方式保留 merge 的 commit 信息. $ git merge --no-ff -m \"keep merge info\" dev # 保留 merge 信息 $ git log --oneline --graph # 输出 * c60668f keep merge info |\\ | * f9584f8 change 3 in dev # 这里就能看出, 我们建立过一个分支 |/ * 47f167e back to change 1 and add comment for 1.py * 904e1ba change 2 * c6762a1 change 1 * 13be9a7 create 1.py ","date":"2021-09-01","objectID":"/posts/git/:3:4","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(commit）解决冲突 如果对于同一个文件，master和dev进行了不同的修改，也就是说在 master 和 dev 上的版本是不同的，此时merge 就会有冲突，提示为 Auto-merging 1.py CONFLICT (content): Merge conflict in 1.py Automatic merge failed; fix conflicts and then commit the result. 此时分支其实已经合并了，但是存在冲突的文件会被git自动进行标注，以方便我们解决冲突，打开1.py可以看到 a = 1 # I went back to change 1 \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD # edited in master ======= # edited in dev \u003e\u003e\u003e\u003e\u003e\u003e\u003e dev 我们只需要手动处理被标记出来的冲突行即可，可以这么进行理解，对于该冲突文件，git进行标记，产生了一个不同于master和dev的第三个版本的文件，此时我们需要手动将该文件编辑为合适的正确的第三版本文件，并记得解决完冲突后进行commit，将其确定为主分支的唯一版本。 然后再 commit 现在的文件, 冲突就解决啦. $ git commit -am \"solve conflict\" 再来看看 master 的 log: $ git log --oneline --graph # 输出 * 7810065 solve conflict |\\ | * f7d2e3a change 3 in dev * | 3d7796e change 4 in master |/ * 47f167e back to change 1 and add comment for 1.py * 904e1ba change 2 * c6762a1 change 1 * 13be9a7 create 1.py 可以看到，第一次merge时，并没有产生版本号，也就是出现冲突后产生了一个“待解决”过渡版本，随后我们解决完冲突后进行commit才可以产生正确的唯一分支。 ","date":"2021-09-01","objectID":"/posts/git/:3:5","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(rebase）变基 同样是合并， rebase 的做法和 merge 不一样. 假设共享的 branch 是 branch B, 而我在 branch A 上工作, 有一天我发现branch B已经有一些小更新, 我也想试试我的程序和这些小更新兼不兼容, 但我并不想直接合并我的未完成版本到 branch A上, 这时就可以用 rebase 来补充我的分支branch B的内容. 补充完以后, 和后面那张图的 merge 不同, 我还是继续在 C3 上工作, 不过此时的 C3 的本质却不一样了, 因为吸收了那些小更新. 所以我们用 C3' 来代替. 原分支\" 原分支 将C3变为变基状态\" 将C3变为变基状态 将C3的基变为C4\" 将C3的基变为C4 以C4为新的基，原分支A上的修改被合并\" 以C4为新的基，原分支A上的修改被合并 可以看出 rebase 改变了 C3 的属性, C3 已经不是从 C1 衍生而来的了. 这一点和 merge 不一样. merge 在合并的时候创建了一个新的 C5 commit. 这一点不同, 使得在共享分支中使用 rebase 变得危险. 如果是共享分支的历史被改写. 别人之前共享内容的 commit 就被你的 rebase 修改掉了. 改写历史\" 改写历史 此外，需要注意的是， !!! 只能在你自己的分支中使用 rebase, 和别人共享的部分是不能用的 !!! 初始的版本库还是和上回一样, 在 master 和 dev 分支中都有自己的独立修改. 在 master创建一个文件后，产生分支，在 master中继续创建第二个文件，然后在dev分支中分两次在文件一中进行修改。 # 这是 master 的 log * bf75fad (HEAD -\u003e master) create 2 * f1e708f create 1 ----------------------------- # 这是 dev 的 log * 103ebbd (HEAD -\u003e dev) add 2 in dev * 7de4a5b add 1 in dev * f1e708f create 1 当我们想要用 rebase 合并 master 到 dev的时候: $ git branch # 输出 *dev master ------------------------- $ git rebase master # 输出 First, rewinding head to replay your work on top of it... Applying: change 3 in dev Using index info to reconstruct a base tree... M 1.py Falling back to patching base and 3-way merge... Auto-merging 1.py CONFLICT (content): Merge conflict in 1.py error: Failed to merge in the changes. Patch failed at 0001 change 3 in dev The copy of the patch that failed is found in: .git/rebase-apply/patch When you have resolved this problem, run \"git rebase --continue\". If you prefer to skip this patch, run \"git rebase --skip\" instead. To check out the original branch and stop rebasing, run \"git rebase --abort\". git 发现的我们的 1.py 在 master 和 dev 上的版本是不同的, 所以提示 merge 有冲突. 具体的冲突, git 已经帮我们标记出来, 我们打开 1.py 就能看到: a = 1 # I went back to change 1 \u003c\u003c\u003c\u003c\u003c\u003c\u003c f7d2e3a047be4624e83c1265a0946e2e8790f79c # edited in dev ======= # edited in master \u003e\u003e\u003e\u003e\u003e\u003e\u003e change 4 in master 这时 HEAD 并没有指向 master 或者 dev, 而是停在了 rebase 模式上: $ git branch * (no branch, rebasing master) # HEAD 在这 dev master 所以我们打开 1.py, 手动合并一下两者的不同. a = 1 # I went back to change 1 ​ # edited in master and dev 然后执行 git add 和 git rebase –continue 就完成了 rebase 的操作了. $ git add 1.py $ git rebase --continue 此时来看看dev的log * 7f28382 (HEAD -\u003e dev) add 2 in dev * 7f26325 add 1 in dev # 基于现在最新的bf75fad进行修改 * bf75fad (master) create 2 * f1e708f create 1 !! 注意 !! 这个例子也说明了使用 rebase 要万分小心, 千万不要在共享的 branch 中 rebase, 不然就像上面那样, 现在 dev 的历史已经被 rebase 改变了. dev 当中别人提交的 change 就被你无情地修改掉了, 所以千万不要在共享分支中使用 rebase.但你可以选择在rebase后merge到master中 $ git checkout master 切换到分支 'master' $ git merge dev 更新 bf75fad..7f28382 Fast-forward 1.py | 3 +++ 1 file changed, 3 insertions(+) 再来看看 master 的 log: $ git log --oneline --graph # 输出 7f28382 (HEAD -\u003e master, dev) add 2 in dev # dev中的修改被合并到master中，且没有产生分支 7f26325 add 1 in dev bf75fad create 2 f1e708f create 1 ","date":"2021-09-01","objectID":"/posts/git/:3:6","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"(stash）临时修改 假如我们正在进行任务A，但是突然有一个紧急bug修改任务B，但是我并不想把我现在的未完成任务A一起提交或者丢弃，此时我们就可以使用stash $ git status -s # 输出 M 1.py ------------------ $ git stash # 输出 Saved working directory and index state WIP on dev: f7d2e3a change 3 in dev HEAD is now at f7d2e3a change 3 in dev ------------------- $ git status # 输出 On branch dev nothing to commit, working directory clean # 干净得很 随后我们完成任务B 完成了, 现在可以继续开心的在 dev 上刷代码了. $ git checkout dev $ git stash list # 查看在 stash 中的缓存 # 输出 stash@{0}: WIP on dev: f7d2e3a change 3 in dev 上面说明在 dev 中, 我们的确有 stash 的工作. 现在可以通过 pop 来提取这个并继续工作了. $ git stash pop # 输出 On branch dev Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: 1.py no changes added to commit (use \"git add\" and/or \"git commit -a\") Dropped refs/stash@{0} (23332b7edc105a579b09b127336240a45756a91c) ---------------------- $ git status -s # 输出 M 1.py # 和最开始一样了 ","date":"2021-09-01","objectID":"/posts/git/:3:7","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"merge和rebase的区别 参考git rebase的一点理解 ","date":"2021-09-01","objectID":"/posts/git/:4:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"merge merge是我们常用的合并分支的命令： 假如开发中：分叉到两个不同的分支，右各自有新的提交： 原分支image \" 原分支 当我们使用merge命令合并时，它会把两个分支的最新提交历史（C3 和 C4）和这个两个分支的最近的祖先（C2）进行三方合并，合并的结果就是生成一个新的提交历史。 举例子来说 假如C2共ABC三个文件 甲在master的基础上修改bug，在A中删除了代码，在C中修改了代码 乙创建新分支来增加功能，在B中新增了代码，在C中修改了代码 而后进行merge，基于C2来进行三方合并，于是在A中删除部分代码，在B中新增代码，然后讨论解决一下C中的冲突，创建了C5版本，完成合并 基于共同历史C2，进行三方合并image \" 基于共同历史C2，进行三方合并 通过合并操作来整合分叉了的历史。 在将三方合并的时候，总是需要以一个提交历史作为依据的，在这个提交历史的基础上增加其他两个的修改，merge上使用的就是这个两个分支的最近的祖先（C2）作为依据。 ","date":"2021-09-01","objectID":"/posts/git/:4:1","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"rebase 首先我们要理解git的版本管理方式，基于上一个历史版本，存储现在的更改，而后现在的版本又作为下一个版本的历史版本。所以，回溯版本相当于把每一个历史版本的更改依次进行还原，跳转之后的版本相当于把每一次更改再重新做一遍。 rebase这个命令在官方的翻译中意思是：变基。 额，怎么说都有点怪是不是，最后查了几个词典，我觉得把rebase翻译为：重定基底 重定基底有两词语组成： 重定：动词，重新确定的意思 基底：名词，就是依据，把某种事物作为依托或根据，在git中，这个依据的事物就是提交历史 合起来就是：重新确定所依据的提交历史。 rebase同样是通过合并来整合分叉的历史，唯一的不同就是，合并时所依据的提交历史不同（基），它是直接拿两个分支的最新提交历史（C3 和 C4）中的一个作为依据（即基），比如以C3为基础，提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 这个过程就相当于改变C4的基底为C3，并将C4上的修改依序应用于C3 上，生成新的C4', 这个过程就改变了C4的基底，也就是所谓的变基。 改变C4的基底为C3，并将C4上的修改依序应用于C3 上，生成新的C4'image \" 改变C4的基底为C3，并将C4上的修改依序应用于C3 上，生成新的C4' 将 C4 中的修改变基到 C3 上。 git rebase [basebranch][topicbranch] ， 以basebranch为基，将topicbranch的修改应用于basebranch上。 $ git checkout experiment $ git rebase master First, rewinding head to replay your work on top of it... Applying: added staged command 这时experiment分支的提交历史就已经改变了，master分支在experiment分支之后。 现在回到 master 分支，进行一次快进合并。 $ git checkout master $ git merge experiment 变基合并可以让最后只剩下一条主线分支image \" 变基合并可以让最后只剩下一条主线分支 此时，C4' 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。如果开发中使用rebase，可以使得最终的开发版本历史只有一条清晰的主分支，在分支上进行的修改也呈现线性记录。 ","date":"2021-09-01","objectID":"/posts/git/:4:2","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"区别 无论是通过变基，还是通过三方合并，最后所生成的结果是一样的，只是他们所生成体提交历史不同。 变基：将一个分支的一系列的提交按顺序应用到另一分支上，前者的所有历史更改被合并为一个大的历史更改保存在历史中。 三方合并：把两方的最后提交合并在一起，因为他们分别的最后提交的版本是基于他们的共同祖先依次迭代更改生成的，所以合并后，每一个分支的所有历史都会被保留。 变基操作的实际是：丢弃一个分支上现有的提交，在另一个分支上新建这些内容但实际上不同的提交。 ","date":"2021-09-01","objectID":"/posts/git/:4:3","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["Doc"],"content":"补充 当你进行了修改，但是没有add和commit时，此时切换到其他分支，如果当前的修改会被覆盖，git会进行警告。 ","date":"2021-09-01","objectID":"/posts/git/:5:0","series":[],"tags":[],"title":"Git","uri":"/posts/git/"},{"categories":["未分类"],"content":"Miniconda是Anaconda的基础版，提供环境管理 ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:0","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":"下载 Miniconda官网 使用最新包的地址下载 $ wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh 下载完成： $ ls Miniconda3-latest-Linux-x86_64.sh ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:1","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":"安装 $ sh Miniconda3-latest-Linux-x86_64.sh Welcome to Miniconda3 py39_4.10.3 In order to continue the installation process, please review the license agreement. Please, press ENTER to continue \u003e\u003e\u003e 回车继续，然后按空格直接跳到文档底部，输入yes并回车 Do you accept the license terms? [yes|no] [no] \u003e\u003e\u003eyes Miniconda3 will now be installed into this location: /home/xxx/miniconda3 - Press ENTER to confirm the location - Press CTRL-C to abort the installation - Or specify a different location below [/home/xxx/miniconda3] \u003e\u003e\u003e 之后一路yes回车即可 ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:2","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":"添加国内源 conda默认从国外服务器上下载包，速度较慢，可换为国内源 清华源 ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:3","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":"创建新环境 conda create -n rnaseq python==3.7 -y 测试python3.7对各种包的支持较好 完成后，进入该环境 $ conda activate rnaseq (rnaseq) xxx@luo-lab-tower:~$ 命令提示符前的括号表示当前的环境，只有进入到该环境中才可以使用该环境中的包，可以创建多个环境，多个环境之间互不影响。 ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:4","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":"安装hisat2-stringtie分析流程所需的软件包 (rnaseq) xxx@luo-lab-tower:~$ conda install fastqc -y fastqc 用于检验reads读数质量 用相同办法继续安装： hisat2 samtools stringtie htseq-count tqdm 参照该博文安装sratoolkit最新版 官方安装包地址：https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/ 最新的应该是2.11.0 技巧 完成以上后，自行google了解这些包的主要用途和基本使用方法。 ","date":"2021-08-13","objectID":"/posts/rnaseq-1/:0:5","series":[],"tags":[],"title":"RNA-seq基础-1-环境配置","uri":"/posts/rnaseq-1/"},{"categories":["未分类"],"content":" 无名的自留地 Keep Alive. ","date":"2021-07-14","objectID":"/about/:0:0","series":[],"tags":[],"title":"关于","uri":"/about/"},{"categories":["未分类"],"content":"🏠 为什么有这个破站 想写东西 想写的东西容易被夹 想给人看又不想给太多人看 想有个随时在线用于分享的笔记本 ","date":"2021-07-14","objectID":"/about/:1:0","series":[],"tags":[],"title":"关于","uri":"/about/"},{"categories":["未分类"],"content":"👨‍💻 博主是谁 高倾向INTP-T(低Fe) P社甲级战犯 天坑专业受害者 内耗自嗨型选手 低电容“warmest machine” 前人类观察者联盟成员 ","date":"2021-07-14","objectID":"/about/:2:0","series":[],"tags":[],"title":"关于","uri":"/about/"},{"categories":["未分类"],"content":"⭐️补充说明 警告！本站可能含有以下不适合所有年龄段群体查看的内容: ⚠️无病呻吟 ⚠️政治暴论 ⚠️种族歧视 ⚠️物种歧视 ⚠️逃亡主义 ⚠️异常模因 ⚠️SCP污染 如还未施加思想钢印，请酌情查看。 ","date":"2021-07-14","objectID":"/about/:3:0","series":[],"tags":[],"title":"关于","uri":"/about/"},{"categories":["未分类"],"content":"❌政治危害声明 如果您属于以下任一群体，请立即退出： 夏皮罗主义者 霍普自由主义者 共有达尔文主义者 科维英主义者 道德达尔文主义者 反动灵魂主义者 虫群意志族群 但本站不包含对任何政治流派的讨论或评价 ","date":"2021-07-14","objectID":"/about/:4:0","series":[],"tags":[],"title":"关于","uri":"/about/"},{"categories":["未分类"],"content":"项目最终效果展示 ","date":"2021-07-13","objectID":"/posts/electron-python/:1:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"概览 为方便使用开源项目piano_transcription而创建，原项目可将钢琴音频通过机器学习模型转化为MIDI文件乐谱(.mid)，原项目每次操作均需要通过命令行输入欲转换的音频文件地址，该GUI可将所有操作为简单的chlick\u0026drag。 ","date":"2021-07-13","objectID":"/posts/electron-python/:2:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"结构 start | V +--------------------+ | | start | electron +-------------\u003e +------------------+ | | sub process | | | (browser or) | | python server | | desktop app | | | | (all html/css/js) | | (business logic) | | | thrift | | | (node.js runtime, | \u003c-----------\u003e | (thrift server) | | thrift client) | communication | | | | | | +--------------------+ +------------------+ electron负责前台，不含任何业务逻辑，在main.js中创建python子线程，python子线程被创建后作为一个client监听转换任务，并调用相关的转换业务，二者通过Apache Thrift进行通信。 ","date":"2021-07-13","objectID":"/posts/electron-python/:3:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"运行效果 ","date":"2021-07-13","objectID":"/posts/electron-python/:4:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"main.js main.js为程序入口和主线程，负责建立窗口和处理来自渲染线程的窗口操作消息，两个线程通过ipc进行通信。 const {app, BrowserWindow, Notification, dialog} = require('electron') // Keep a global reference of the window object, if you don't, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () { // 创建浏览器窗口。 win = new BrowserWindow({ width: 1000, height: 800, webPreferences:{nodeIntegration:true}, transparent: true, frame: false, resizable:false, // backgroundColor: '#00000000', }) // 然后加载应用的 index.html。 win.loadFile('new_index.html') // 打开开发者工具 // win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on('closed', () =\u003e { // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null }) } // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on('ready', createWindow) // 当全部窗口关闭时退出。 app.on('window-all-closed', () =\u003e { // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== 'darwin') { app.quit() } }) app.on('activate', () =\u003e { // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) { createWindow() } }) // 在这个文件中，可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 const path=require('path') let pyProc = null let pyPort = null const createPyProc = () =\u003e { // let port = '4242' let script = path.join(__dirname, 'py', 'thrift_server.py') pyProc = require('child_process').spawn('python', [script]) // let script = path.join(__dirname, 'py', 'dist','thrift_server', 'thrift_server.exe') // pyProc = require('child_process').execFile(script) if (pyProc != null) { console.log('child process success') } } const exitPyProc = () =\u003e { pyProc.kill() pyProc = null pyPort = null } let ipcMain = require('electron').ipcMain; //接收最小化命令 ipcMain.on('window-min', function() { win.minimize(); }) //接收最大化命令 ipcMain.on('window-max', function() { if (win.isMaximized()) { win.restore(); } else { win.maximize(); } }) //接收关闭命令 ipcMain.on('window-close', function() { win.close(); }) //拖动保存文件 ipcMain.on('ondragstart', (event, filePath) =\u003e { event.sender.startDrag({ file: filePath, icon: './icon.png' }) }) //显示通知 function showNotification (){ const notification = { title: 'Piano transcription E', body: '转换任务已完成' } new Notification(notification).show() } ipcMain.on('showNotification', function() { showNotification(); }) //接收打开对话框事件，完成后，回传获取到的文件路径到渲染线程 ipcMain.on('openDialog',(event, arg) =\u003e { dialog.showOpenDialog({ properties: ['openFile', 'multiSelections'] }).then(result=\u003e{ console.log(result.filePaths); //输出结果 if (result.filePaths.length\u003e0) { event.reply('selectedItem', result.filePaths) } }) }) //设置应用启动关闭时联动python子线程 app.on('ready', createPyProc) app.on('will-quit', exitPyProc) ","date":"2021-07-13","objectID":"/posts/electron-python/:5:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"render.js render线程作为页面逻辑元素被加载，负责建立thrift子线程，与子线程通信，并相应鼠标点击事件转换为事件信息传入主线程以控制桌面应用下的窗口。 // renderer.js var thrift = require('thrift'); // 调用win10下thrift命令自动生成的依赖包 var TranscriptionService = require('./gen-nodejs/TranscriptionService.js'); var ttypes = require('./gen-nodejs/trans_types.js'); // thrift 通信会占用一个本地端口 var thriftConnection = thrift.createConnection('127.0.0.1', 8000); var thriftClient = thrift.createClient(TranscriptionService,thriftConnection); var fs = require('fs'); //建立thrift子线程 thriftConnection.on(\"error\",function(e) { console.log(e); }); // let name = document.querySelector('#name') // let result = document.querySelector('#result') let ipcRenderer = require('electron').ipcRenderer; //响应点击最大化按钮 var max = document.getElementById('max'); if (max) { max.addEventListener('click', () =\u003e { //发送最大化命令 ipcRenderer.send('window-max'); //最大化图形切换 if (max.getAttribute('src') == 'images/max.png') { max.setAttribute('src', 'images/maxed.png'); } else { max.setAttribute('src', 'images/max.png'); } }) } //响应点击最小化按钮 var min = document.getElementById('min'); if (min) { min.addEventListener('click', () =\u003e { //发送最小化命令 ipcRenderer.send('window-min'); }) } //响应点击关闭按钮 var close = document.getElementById('close'); if (close) { close.addEventListener('click', () =\u003e { //发送关闭命令 ipcRenderer.send('window-close'); }) } //拖动保存文件 document.getElementById('drag_save').ondragstart = (event) =\u003e { event.preventDefault() ipcRenderer.send('ondragstart', dragTosavePath) } //响应点击开始转换按钮 var dragTosavePath = 'C:/Development/Projects/piano_transcription/output/test.mid' var transcript = document.getElementById(\"transcript\"); if (transcript) { transcript.addEventListener('click', () =\u003e { // document.getElementById(\"progressDiv\").innerHTML='\u003cdiv class=\"progress-bar progress-bar-striped progress-bar-animated bg-primary\" role=\"progressbar\" style=\"width: 100% ;height: 20px;\" aria-valuenow=\"25\" aria-valuemin=\"0\" aria-valuemax=\"100\"\u003e\u003c/div\u003e' // document.getElementById(\"progressDiv\").setAttribute(\"hidden\",true); document.getElementById(\"progressDiv\").removeAttribute(\"hidden\") document.getElementById(\"transcript\").classList.add(\"disabled\") document.getElementById(\"transcript\").innerHTML = \"processing...\" var dic = {paths: filePaths} dic = JSON.stringify(dic) thriftClient.music2mid(dic, (error, res) =\u003e { if(error) { console.error(error) } else { Swal.fire(\"完成!\", \"您的所有转换任务已完成!\", \"success\"); ipcRenderer.send('showNotification'); document.getElementById(\"transcript\").classList.remove(\"disabled\") document.getElementById(\"transcript\").innerHTML = \"start\" document.getElementById(\"progressDiv\").setAttribute(\"hidden\",true) document.getElementById(\"drag_save\").removeAttribute(\"hidden\") midPaths = JSON.parse(res)['output_paths'] dragTosavePath = midPaths[0] console.log(dragTosavePath) } }) }) }; //响应点击以打开文件 function openDialog(){ ipcRenderer.send('openDialog'); }; ipcRenderer.on('selectedItem', (event, paths)=\u003e{ // console.log('render:'); // console.log(paths); fileNum += paths.length; filePaths = filePaths.concat(paths) refreshFileNum() }); var clickOpen = document.getElementById('drag_open'); if (clickOpen) { clickOpen.addEventListener('click', () =\u003e { openDialog() }) }; //拖拽打开功能 const dragWrapper = document.getElementById(\"drag_open\"); //添加拖拽事件监听器 dragWrapper.addEventListener(\"drop\", (e) =\u003e { //阻止默认行为 e.preventDefault(); //获取文件列表 const files = e.dataTransfer.files; var paths = new Array(); for (let file of files){ //获取文件路径 paths.push(file.path) } // console.log(paths); fileNum += paths.length; filePaths = filePaths.concat(paths) refreshFileNum(); }); //阻止拖拽结束事件默认行为 dragWrapper.addEventListener(\"dragover\", (e) =\u003e { e.preventDefault(); }); var fileNum = 0; var filePaths = new Array(); const fileNumLabel = document.getElementById(\"fileNumLabel\"); const fileList = document.getElementById(\"fileList\"); function refreshFileNum(){ fileNumLabel.innerHTML='已选择'+fileNum+'个文件' fileList.innerHTML='\u003cspan\u003e支持导入单个或多个音频文件\u003c/span\u003e' for (let file of filePaths){ let arr = file.split(\"\\\\\") let fileS","date":"2021-07-13","objectID":"/posts/electron-python/:6:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"thrift.py thrift.py负责处理业务逻辑部分，并创建thrift服务端，相应转换指令，需要注意的是，前台传入的仅为欲转换音频文件的路径，python完成转换后传回生成的mid文件路径。 import json from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer from gen_py.trans import TranscriptionService from piano_transcription_inference import PianoTranscription, sample_rate, load_audio import os checkpoint_path = 'py/piano_transcription_inference_data/note_F1=0.9677_pedal_F1=0.9186.pth' class Transcription: def music2mid(self, dic): output_files_list = [] print(dic) def mp32mid(fp): # Load audio (audio, _) = load_audio(fp, sr=sample_rate, mono=True) print('loaded') # Transcriptor transcriptor = PianoTranscription(device='cuda', checkpoint_path=checkpoint_path) # 'cuda' | 'cpu' fname=fp.split('\\\\')[-1] print(fname+' is processing...') # Transcribe and write out to MIDI file output_file = os.getcwd()+'\\\\py\\\\output\\\\' + fname + '.mid' transcribed_dict = transcriptor.transcribe(audio, output_file) # 设置输出路径（文件名） return output_file dic = json.loads(dic) for path in dic[\"paths\"]: output_files_list.append(mp32mid(path)) res = json.dumps({\"output_paths\":output_files_list}) return res return f'{res}' if __name__ == \"__main__\": port = 8000 ip = \"127.0.0.1\" # 创建服务端 handler = Transcription() # 自定义类 processor = TranscriptionService.Processor(handler) # userService为python接口文件自动生成 # 监听端口 transport = TSocket.TServerSocket(ip, port) # ip与port位置不可交换 # 选择传输层 tfactory = TTransport.TBufferedTransportFactory() # 选择传输协议 pfactory = TBinaryProtocol.TBinaryProtocolFactory() # 创建服务端 server = TServer.TThreadedServer(processor, transport, tfactory, pfactory) print(\"start server in python\") server.serve() print(\"Done\") ","date":"2021-07-13","objectID":"/posts/electron-python/:7:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"thrift接口文件的生成 由于thrift接口连接两种语言，所以需要对接口进行定义 ","date":"2021-07-13","objectID":"/posts/electron-python/:8:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"trans.thrift service TranscriptionService { string music2mid(1:string name) } 然后使用 thrift.exe -out ./gen_py -gen py trans.thrift ''' ./gen_py │__init__.py │ └trans │ constants.py │ TranscriptionService-remote │ TranscriptionService.py │ ttypes.py └ __init__.py ''' thrift.exe -out ./gen_nodejs --gen js:node trans.thrift ''' ./gen_nodejs ├─TranscriptionService.js └─trans_types.js 生成对应语言的接口程序供调用 Python中的调用： from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer Electron(node.js)中的调用： JavaScript中的调用： var thrift = require('thrift'); // 调用win10下thrift命令自动生成的依赖包 var TranscriptionService = require('./gen-nodejs/TranscriptionService.js'); var ttypes = require('./gen-nodejs/trans_types.js'); // thrift 通信会占用一个本地端口 var thriftConnection = thrift.createConnection('127.0.0.1', 8000); var thriftClient = thrift.createClient(TranscriptionService,thriftConnection); ","date":"2021-07-13","objectID":"/posts/electron-python/:9:0","series":[],"tags":[],"title":"Electron Python","uri":"/posts/electron-python/"},{"categories":["未分类"],"content":"路线图 ","date":"2021-07-13","objectID":"/posts/qinghai/:0:1","series":[],"tags":[],"title":"青海行","uri":"/posts/qinghai/"},{"categories":["未分类"],"content":"第一天 7/17 下午2时降落，乘车到市区，入住酒店（） 必要事项 联系司机，车辆 购买物资：水，干粮、其他防护器具、防晒等 可选市内景点 饮食：莫家街和饮马街 夜景，地标建筑：浦宁之珠 ","date":"2021-07-13","objectID":"/posts/qinghai/:0:2","series":[],"tags":[],"title":"青海行","uri":"/posts/qinghai/"},{"categories":["未分类"],"content":"第二天 7/18 西宁出发，前往塔尔寺 拉脊山 青海湖 茶卡镇 ","date":"2021-07-13","objectID":"/posts/qinghai/:0:3","series":[],"tags":[],"title":"青海行","uri":"/posts/qinghai/"},{"categories":["未分类"],"content":"第三天 7/19 ","date":"2021-07-13","objectID":"/posts/qinghai/:0:4","series":[],"tags":[],"title":"青海行","uri":"/posts/qinghai/"},{"categories":["未分类"],"content":"前言 19年4月19日，陪伴我多年的变色眼镜终于光荣退役了，在镜框的纵容下，左眼镜片选择结束自己的使命奔向了自由。 这是我的第三副眼镜，当时心血来潮选择的变色片，变色片虽然用着舒服，但是因为如下原因不太想用第二次： 镜片变色取决于紫外线强度，所以，开车没用（挡风玻璃有过滤紫外线作用），下雨天或者阴天却有可能变色，你能想到在一个阴郁的傍晚看一个戴墨镜的人有多傻叼吗？ 墨镜自带一丢丢的装逼属性，虽然很多时候都是为了眼睛舒服，别人觉得装逼就装吧，反正戴上墨镜别人认不出（还可以遮挡视线看可爱的小姐姐），但是，变色片不一样，它会变色，但是却不会像墨镜那样黑，别人还是能看见你，认出你（还挡不了视线）。所以你有时会看到走在路上别人会看你，毕竟变色片还不是特别主流。 变色片恢复时间还是比较长，突然从阳光下进入室内会很不适应，相当于室内戴墨镜你还没法取，而且如果在眼镜还是半黑的情况下去见长辈或者老师感觉很不礼貌 变色片就当是个玩具，如果有长时间的室外工作需求还是可以弄一副，比墨镜还是方便一点，虽然没有墨镜帅。 高度近视患者没有备用镜，简直生活都没办法自理，虽然我还有一个争气的右眼200度能撑一下，之前一直觉得眼镜是个暴利行业，一副普普通通的框一堆名词忽悠来就敢买一两千，毛利率甚至超过95%，但是看了一个“挺着暴利光环挣扎在温饱线上的眼镜店主”写的帖子，对这个行业有了不一样的看法，眼镜确实是单品利率高，但是店铺利率低，为什么？卖的少啊，眼镜又不像手机，隔一两年还搞个更新换代，如果不是出什么问题或者度数猛涨，一般人戴个十年八年没有任何问题，很多店撑死两三天卖一副，水电气加房租一减，维持温饱还是很轻松，真不是别人想坑你钱，实在是运营模式下没办法。 有人一听好耳熟，水电房租这好办，网购啊，网店不就是摆脱了这些固定成本吗？其实尝试的人还真不少，国内几家大牌都有网上商城，但是眼镜作为一个定制化程度极高的产品，在网购中处处水土不服。验光问题–要去医院，选框问题–好吧别人寄几幅您挑，挑好了还得给别人退回去，然后都选妥了别人再工厂生产完给您寄过去，一来二去大半个月就没了，我还不如直接去街上找家眼镜店呢。 这次配镜和以前不一样，大学里终于有充足的时间去配一副眼镜了，不像以前老妈带着，火速完事儿。在网上查资料做了很多功课，算是小有心得，在这里做个分享记录。 ","date":"2021-07-12","objectID":"/posts/glass/:0:1","series":[],"tags":[],"title":"眼镜新鸟的经验谈","uri":"/posts/glass/"},{"categories":["未分类"],"content":"“快时尚品牌”？ 眼镜行业发展到现在，还有突破的可能吗？ 还真有，既然实体店面临成本高风险等压力，还是可以沿用互联网那一套，定位年轻市场，重设计，打造网红体验，走量来保证利率。所以一批“快时尚”品牌迅速兴起，以\"快、狠、准\"为主要特征，换成直接体验就是店铺的装修时尚气息浓厚、购物氛围自由、服务贴心；其次，产品时尚潮流度较高，更新速度快，同时价格亲民，不会像普通眼镜店那样一直有一个店员跟着你碎碎念（社恐噩梦），镜架不会锁在玻璃柜子里而是摆在货架上可以随意试戴，有需要店员也会给你一些建议，体验好了不少。目前国内比较火的快时尚品牌有JINS(睛姿)、LOHO眼镜生活、木九十、ZOFF(佐芙)、Aojo(艾镜)、EXE镜自由、eGG、URAKU(乐顾)、Zele、LookOptical等。 在小红书和什么值得买上，Jins可以说是众人的心头好，具体购买帖自己去搜，不在累述。定位年轻和高性价比的标签深得我心，所以就选它家的眼镜了，先是打算网购，但是没有办法试戴让我这个脸形不好撘的人知难而退。一搜发现成都的店面还真不太少，大概有七八家，选了从图片上看店面最大的环球中心店。 环球中心巨无霸的体积着实让我这个处于半失明状态的人找了好一阵，到了店门口就发现和外面那些妖艳贱货果然不一样，和周围的时装大牌完美融为一体，温馨的装修和开放的镜架让一些不打算配镜的人都有进去逛逛的冲动。 最后在店员小姐姐的推荐下选了一个999的钛框，考虑到左眼500的度数,加300元上了1.67，搞活动再优惠一百，到手价1199.由于需要定制镜片，5-7天后才能取镜或者邮寄，开箱图待补 下面是重点，在近几年一些媒体的刻意引导下，消费者和商家之间的信息不对等被刻意放大，很多人都觉得“商家的嘴，骗人的鬼”，当然一些无良商家也对造成这样的局面功不可没，我还是相信世界上还是好人多，有些商家还是会很贴心地帮你选择商品的，如果你还是觉得不太保险，那么最好的办法就是消除问题的根源–信息不平等，如果你能够分辨出商家嘴里每个晦涩难懂的词语的意思，那再没人能够骗到你。 ","date":"2021-07-12","objectID":"/posts/glass/:0:2","series":[],"tags":[],"title":"眼镜新鸟的经验谈","uri":"/posts/glass/"},{"categories":["未分类"],"content":"1.56? 1.60? 1.67？ 眼镜是通过折射改变入射光线，从而使外界的光线能够在视网膜上清晰成像，以达到矫正视力的目的。每人需要矫正的程度，或者说近视（远视）的度数不一样，通过改变镜片的形状或者折射率就可以实现不同的矫正度数。而商家在选择镜片时所说的1.56\\1.67就是指的镜片折射率，一般来说，折射率越高，镜片就越薄，随之重量下降和美观度也会提升。但对于低度数的同学来说，不同折射率之间的镜片薄厚差距微乎其微，而价格之间的差距就比较大了。高折射率的优势只有在高倍镜中才能体现出来。 1、100度以下的近视或平光，或者100度以下的远视，建议选择1.50折射率的镜片； 2、100~300度的近视，或者100~300度以下的远视，建议选择1.56折射率的镜片； 3、300~600度的近视，或者300度~600度以下的远视，建议选择1.60折射率的镜片； 4、600~800度的近视，建议选择1.67折射率的镜片； 5、800度以上的近视，建议选择1.74折射率的镜片。 ","date":"2021-07-12","objectID":"/posts/glass/:0:3","series":[],"tags":[],"title":"眼镜新鸟的经验谈","uri":"/posts/glass/"},{"categories":["未分类"],"content":"阿贝数？ 可能有的同学会想，我有钱，任性，虽然我度数不高，但是我就要选最贵的1.74折射率，那减少的零点几克重量对本仙女很重要。这样选择并不理智，这就涉及到一个商家往往不会告诉你的参数–阿贝数（色散系数）。 先来复习一下高中物理—同种介质对不同波长的光有不同的折射率。通过这个原理，我们可以造出三棱镜，将不同波长的光分开，衡量这种能力的指标就是阿贝数，色散现象在眼镜中同样存在，一些高度近视的朋友在通过眼镜边缘看物体时有时会发现物体边缘有蓝边，这就是发生了色散。色散程度越低，成像的效果越好，不同折射率的眼镜阿贝数参考如下 总体来说，1.50折射率的镜片的阿贝数可以达到58，但是一旦用到1.74折射率超超薄以上等级的镜片时，阿贝数会下降到32~36。所以，有好就有坏。如果一味追求镜片的薄，那么就会牺牲镜片的阿贝数，也就是降低了视觉对于颜色的真实感受，以及舒适度。 ","date":"2021-07-12","objectID":"/posts/glass/:0:4","series":[],"tags":[],"title":"眼镜新鸟的经验谈","uri":"/posts/glass/"}]