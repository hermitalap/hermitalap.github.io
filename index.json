[{"categories":null,"content":"项目最终效果展示 ","date":"2021-07-13","objectID":"/electron-python/:1:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"概览 为方便使用开源项目piano_transcription而创建，原项目可将钢琴音频通过机器学习模型转化为MIDI文件乐谱(.mid)，原项目每次操作均需要通过命令行输入欲转换的音频文件地址，该GUI可将所有操作为简单的chlick\u0026drag。 ","date":"2021-07-13","objectID":"/electron-python/:2:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"结构 start | V +--------------------+ | | start | electron +-------------\u003e +------------------+ | | sub process | | | (browser or) | | python server | | desktop app | | | | (all html/css/js) | | (business logic) | | | thrift | | | (node.js runtime, | \u003c-----------\u003e | (thrift server) | | thrift client) | communication | | | | | | +--------------------+ +------------------+ electron负责前台，不含任何业务逻辑，在main.js中创建python子线程，python子线程被创建后作为一个client监听转换任务，并调用相关的转换业务，二者通过Apache Thrift进行通信。 ","date":"2021-07-13","objectID":"/electron-python/:3:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"运行效果 ","date":"2021-07-13","objectID":"/electron-python/:4:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"main.js main.js为程序入口和主线程，负责建立窗口和处理来自渲染线程的窗口操作消息，两个线程通过ipc进行通信。 const {app, BrowserWindow, Notification, dialog} = require('electron') // Keep a global reference of the window object, if you don't, the window will // be closed automatically when the JavaScript object is garbage collected. let win function createWindow () { // 创建浏览器窗口。 win = new BrowserWindow({ width: 1000, height: 800, webPreferences:{nodeIntegration:true}, transparent: true, frame: false, resizable:false, // backgroundColor: '#00000000', }) // 然后加载应用的 index.html。 win.loadFile('new_index.html') // 打开开发者工具 // win.webContents.openDevTools() // 当 window 被关闭，这个事件会被触发。 win.on('closed', () =\u003e { // 取消引用 window 对象，如果你的应用支持多窗口的话， // 通常会把多个 window 对象存放在一个数组里面， // 与此同时，你应该删除相应的元素。 win = null }) } // Electron 会在初始化后并准备 // 创建浏览器窗口时，调用这个函数。 // 部分 API 在 ready 事件触发后才能使用。 app.on('ready', createWindow) // 当全部窗口关闭时退出。 app.on('window-all-closed', () =\u003e { // 在 macOS 上，除非用户用 Cmd + Q 确定地退出， // 否则绝大部分应用及其菜单栏会保持激活。 if (process.platform !== 'darwin') { app.quit() } }) app.on('activate', () =\u003e { // 在macOS上，当单击dock图标并且没有其他窗口打开时， // 通常在应用程序中重新创建一个窗口。 if (win === null) { createWindow() } }) // 在这个文件中，可以续写应用剩下主进程代码。 // 也可以拆分成几个文件，然后用 require 导入。 const path=require('path') let pyProc = null let pyPort = null const createPyProc = () =\u003e { // let port = '4242' let script = path.join(__dirname, 'py', 'thrift_server.py') pyProc = require('child_process').spawn('python', [script]) // let script = path.join(__dirname, 'py', 'dist','thrift_server', 'thrift_server.exe') // pyProc = require('child_process').execFile(script) if (pyProc != null) { console.log('child process success') } } const exitPyProc = () =\u003e { pyProc.kill() pyProc = null pyPort = null } let ipcMain = require('electron').ipcMain; //接收最小化命令 ipcMain.on('window-min', function() { win.minimize(); }) //接收最大化命令 ipcMain.on('window-max', function() { if (win.isMaximized()) { win.restore(); } else { win.maximize(); } }) //接收关闭命令 ipcMain.on('window-close', function() { win.close(); }) //拖动保存文件 ipcMain.on('ondragstart', (event, filePath) =\u003e { event.sender.startDrag({ file: filePath, icon: './icon.png' }) }) //显示通知 function showNotification (){ const notification = { title: 'Piano transcription E', body: '转换任务已完成' } new Notification(notification).show() } ipcMain.on('showNotification', function() { showNotification(); }) //接收打开对话框事件，完成后，回传获取到的文件路径到渲染线程 ipcMain.on('openDialog',(event, arg) =\u003e { dialog.showOpenDialog({ properties: ['openFile', 'multiSelections'] }).then(result=\u003e{ console.log(result.filePaths); //输出结果 if (result.filePaths.length\u003e0) { event.reply('selectedItem', result.filePaths) } }) }) //设置应用启动关闭时联动python子线程 app.on('ready', createPyProc) app.on('will-quit', exitPyProc) ","date":"2021-07-13","objectID":"/electron-python/:5:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"render.js render线程作为页面逻辑元素被加载，负责建立thrift子线程，与子线程通信，并相应鼠标点击事件转换为事件信息传入主线程以控制桌面应用下的窗口。 // renderer.js var thrift = require('thrift'); // 调用win10下thrift命令自动生成的依赖包 var TranscriptionService = require('./gen-nodejs/TranscriptionService.js'); var ttypes = require('./gen-nodejs/trans_types.js'); // thrift 通信会占用一个本地端口 var thriftConnection = thrift.createConnection('127.0.0.1', 8000); var thriftClient = thrift.createClient(TranscriptionService,thriftConnection); var fs = require('fs'); //建立thrift子线程 thriftConnection.on(\"error\",function(e) { console.log(e); }); // let name = document.querySelector('#name') // let result = document.querySelector('#result') let ipcRenderer = require('electron').ipcRenderer; //响应点击最大化按钮 var max = document.getElementById('max'); if (max) { max.addEventListener('click', () =\u003e { //发送最大化命令 ipcRenderer.send('window-max'); //最大化图形切换 if (max.getAttribute('src') == 'images/max.png') { max.setAttribute('src', 'images/maxed.png'); } else { max.setAttribute('src', 'images/max.png'); } }) } //响应点击最小化按钮 var min = document.getElementById('min'); if (min) { min.addEventListener('click', () =\u003e { //发送最小化命令 ipcRenderer.send('window-min'); }) } //响应点击关闭按钮 var close = document.getElementById('close'); if (close) { close.addEventListener('click', () =\u003e { //发送关闭命令 ipcRenderer.send('window-close'); }) } //拖动保存文件 document.getElementById('drag_save').ondragstart = (event) =\u003e { event.preventDefault() ipcRenderer.send('ondragstart', dragTosavePath) } //响应点击开始转换按钮 var dragTosavePath = 'C:/Development/Projects/piano_transcription/output/test.mid' var transcript = document.getElementById(\"transcript\"); if (transcript) { transcript.addEventListener('click', () =\u003e { // document.getElementById(\"progressDiv\").innerHTML='\u003cdiv class=\"progress-bar progress-bar-striped progress-bar-animated bg-primary\" role=\"progressbar\" style=\"width: 100% ;height: 20px;\" aria-valuenow=\"25\" aria-valuemin=\"0\" aria-valuemax=\"100\"\u003e\u003c/div\u003e' // document.getElementById(\"progressDiv\").setAttribute(\"hidden\",true); document.getElementById(\"progressDiv\").removeAttribute(\"hidden\") document.getElementById(\"transcript\").classList.add(\"disabled\") document.getElementById(\"transcript\").innerHTML = \"processing...\" var dic = {paths: filePaths} dic = JSON.stringify(dic) thriftClient.music2mid(dic, (error, res) =\u003e { if(error) { console.error(error) } else { Swal.fire(\"完成!\", \"您的所有转换任务已完成!\", \"success\"); ipcRenderer.send('showNotification'); document.getElementById(\"transcript\").classList.remove(\"disabled\") document.getElementById(\"transcript\").innerHTML = \"start\" document.getElementById(\"progressDiv\").setAttribute(\"hidden\",true) document.getElementById(\"drag_save\").removeAttribute(\"hidden\") midPaths = JSON.parse(res)['output_paths'] dragTosavePath = midPaths[0] console.log(dragTosavePath) } }) }) }; //响应点击以打开文件 function openDialog(){ ipcRenderer.send('openDialog'); }; ipcRenderer.on('selectedItem', (event, paths)=\u003e{ // console.log('render:'); // console.log(paths); fileNum += paths.length; filePaths = filePaths.concat(paths) refreshFileNum() }); var clickOpen = document.getElementById('drag_open'); if (clickOpen) { clickOpen.addEventListener('click', () =\u003e { openDialog() }) }; //拖拽打开功能 const dragWrapper = document.getElementById(\"drag_open\"); //添加拖拽事件监听器 dragWrapper.addEventListener(\"drop\", (e) =\u003e { //阻止默认行为 e.preventDefault(); //获取文件列表 const files = e.dataTransfer.files; var paths = new Array(); for (let file of files){ //获取文件路径 paths.push(file.path) } // console.log(paths); fileNum += paths.length; filePaths = filePaths.concat(paths) refreshFileNum(); }); //阻止拖拽结束事件默认行为 dragWrapper.addEventListener(\"dragover\", (e) =\u003e { e.preventDefault(); }); var fileNum = 0; var filePaths = new Array(); const fileNumLabel = document.getElementById(\"fileNumLabel\"); const fileList = document.getElementById(\"fileList\"); function refreshFileNum(){ fileNumLabel.innerHTML='已选择'+fileNum+'个文件' fileList.innerHTML='\u003cspan\u003e支持导入单个或多个音频文件\u003c/span\u003e' for (let file of filePaths){ let arr = file.split(\"\\\\\") let fileS","date":"2021-07-13","objectID":"/electron-python/:6:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"thrift.py thrift.py负责处理业务逻辑部分，并创建thrift服务端，相应转换指令，需要注意的是，前台传入的仅为欲转换音频文件的路径，python完成转换后传回生成的mid文件路径。 import json from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer from gen_py.trans import TranscriptionService from piano_transcription_inference import PianoTranscription, sample_rate, load_audio import os checkpoint_path = 'py/piano_transcription_inference_data/note_F1=0.9677_pedal_F1=0.9186.pth' class Transcription: def music2mid(self, dic): output_files_list = [] print(dic) def mp32mid(fp): # Load audio (audio, _) = load_audio(fp, sr=sample_rate, mono=True) print('loaded') # Transcriptor transcriptor = PianoTranscription(device='cuda', checkpoint_path=checkpoint_path) # 'cuda' | 'cpu' fname=fp.split('\\\\')[-1] print(fname+' is processing...') # Transcribe and write out to MIDI file output_file = os.getcwd()+'\\\\py\\\\output\\\\' + fname + '.mid' transcribed_dict = transcriptor.transcribe(audio, output_file) # 设置输出路径（文件名） return output_file dic = json.loads(dic) for path in dic[\"paths\"]: output_files_list.append(mp32mid(path)) res = json.dumps({\"output_paths\":output_files_list}) return res return f'{res}' if __name__ == \"__main__\": port = 8000 ip = \"127.0.0.1\" # 创建服务端 handler = Transcription() # 自定义类 processor = TranscriptionService.Processor(handler) # userService为python接口文件自动生成 # 监听端口 transport = TSocket.TServerSocket(ip, port) # ip与port位置不可交换 # 选择传输层 tfactory = TTransport.TBufferedTransportFactory() # 选择传输协议 pfactory = TBinaryProtocol.TBinaryProtocolFactory() # 创建服务端 server = TServer.TThreadedServer(processor, transport, tfactory, pfactory) print(\"start server in python\") server.serve() print(\"Done\") ","date":"2021-07-13","objectID":"/electron-python/:7:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"thrift接口文件的生成 由于thrift接口连接两种语言，所以需要对接口进行定义 ","date":"2021-07-13","objectID":"/electron-python/:8:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"trans.thrift service TranscriptionService { string music2mid(1:string name) } 然后使用 thrift.exe -out ./gen_py -gen py trans.thrift ''' ./gen_py │__init__.py │ └trans │ constants.py │ TranscriptionService-remote │ TranscriptionService.py │ ttypes.py └ __init__.py ''' thrift.exe -out ./gen_nodejs --gen js:node trans.thrift ''' ./gen_nodejs ├─TranscriptionService.js └─trans_types.js 生成对应语言的接口程序供调用 Python中的调用： from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer Electron(node.js)中的调用： JavaScript中的调用： var thrift = require('thrift'); // 调用win10下thrift命令自动生成的依赖包 var TranscriptionService = require('./gen-nodejs/TranscriptionService.js'); var ttypes = require('./gen-nodejs/trans_types.js'); // thrift 通信会占用一个本地端口 var thriftConnection = thrift.createConnection('127.0.0.1', 8000); var thriftClient = thrift.createClient(TranscriptionService,thriftConnection); ","date":"2021-07-13","objectID":"/electron-python/:9:0","series":null,"tags":null,"title":"Electron Python","uri":"/electron-python/"},{"categories":null,"content":"路线图 ","date":"2021-07-13","objectID":"/qinghai/:0:1","series":null,"tags":null,"title":"青海行","uri":"/qinghai/"},{"categories":null,"content":"第一天 7/17 下午2时降落，乘车到市区，入住酒店（） 必要事项\r\r联系司机，车辆 购买物资：水，干粮、其他防护器具、防晒等 \r\r 可选市内景点\r\r饮食：莫家街和饮马街 夜景，地标建筑：浦宁之珠 \r\r ","date":"2021-07-13","objectID":"/qinghai/:0:2","series":null,"tags":null,"title":"青海行","uri":"/qinghai/"},{"categories":null,"content":"第二天 7/18 西宁出发，前往塔尔寺 拉脊山 青海湖 茶卡镇 ","date":"2021-07-13","objectID":"/qinghai/:0:3","series":null,"tags":null,"title":"青海行","uri":"/qinghai/"},{"categories":null,"content":"第三天 7/19 ","date":"2021-07-13","objectID":"/qinghai/:0:4","series":null,"tags":null,"title":"青海行","uri":"/qinghai/"},{"categories":null,"content":"前言 19年4月19日，陪伴我多年的变色眼镜终于光荣退役了，在镜框的纵容下，左眼镜片选择结束自己的使命奔向了自由。 这是我的第三副眼镜，当时心血来潮选择的变色片，变色片虽然用着舒服，但是因为如下原因不太想用第二次： 镜片变色取决于紫外线强度，所以，开车没用（挡风玻璃有过滤紫外线作用），下雨天或者阴天却有可能变色，你能想到在一个阴郁的傍晚看一个戴墨镜的人有多傻叼吗？ 墨镜自带一丢丢的装逼属性，虽然很多时候都是为了眼睛舒服，别人觉得装逼就装吧，反正戴上墨镜别人认不出（还可以遮挡视线看可爱的小姐姐），但是，变色片不一样，它会变色，但是却不会像墨镜那样黑，别人还是能看见你，认出你（还挡不了视线）。所以你有时会看到走在路上别人会看你，毕竟变色片还不是特别主流。 变色片恢复时间还是比较长，突然从阳光下进入室内会很不适应，相当于室内戴墨镜你还没法取，而且如果在眼镜还是半黑的情况下去见长辈或者老师感觉很不礼貌 变色片就当是个玩具，如果有长时间的室外工作需求还是可以弄一副，比墨镜还是方便一点，虽然没有墨镜帅。 高度近视患者没有备用镜，简直生活都没办法自理，虽然我还有一个争气的右眼200度能撑一下，之前一直觉得眼镜是个暴利行业，一副普普通通的框一堆名词忽悠来就敢买一两千，毛利率甚至超过95%，但是看了一个“挺着暴利光环挣扎在温饱线上的眼镜店主”写的帖子，对这个行业有了不一样的看法，眼镜确实是单品利率高，但是店铺利率低，为什么？卖的少啊，眼镜又不像手机，隔一两年还搞个更新换代，如果不是出什么问题或者度数猛涨，一般人戴个十年八年没有任何问题，很多店撑死两三天卖一副，水电气加房租一减，维持温饱还是很轻松，真不是别人想坑你钱，实在是运营模式下没办法。 有人一听好耳熟，水电房租这好办，网购啊，网店不就是摆脱了这些固定成本吗？其实尝试的人还真不少，国内几家大牌都有网上商城，但是眼镜作为一个定制化程度极高的产品，在网购中处处水土不服。验光问题–要去医院，选框问题–好吧别人寄几幅您挑，挑好了还得给别人退回去，然后都选妥了别人再工厂生产完给您寄过去，一来二去大半个月就没了，我还不如直接去街上找家眼镜店呢。 这次配镜和以前不一样，大学里终于有充足的时间去配一副眼镜了，不像以前老妈带着，火速完事儿。在网上查资料做了很多功课，算是小有心得，在这里做个分享记录。 ","date":"2021-07-12","objectID":"/glass/:0:1","series":null,"tags":null,"title":"眼镜新鸟的经验谈","uri":"/glass/"},{"categories":null,"content":"“快时尚品牌”？ 眼镜行业发展到现在，还有突破的可能吗？ 还真有，既然实体店面临成本高风险等压力，还是可以沿用互联网那一套，定位年轻市场，重设计，打造网红体验，走量来保证利率。所以一批“快时尚”品牌迅速兴起，以\"快、狠、准\"为主要特征，换成直接体验就是店铺的装修时尚气息浓厚、购物氛围自由、服务贴心；其次，产品时尚潮流度较高，更新速度快，同时价格亲民，不会像普通眼镜店那样一直有一个店员跟着你碎碎念（社恐噩梦），镜架不会锁在玻璃柜子里而是摆在货架上可以随意试戴，有需要店员也会给你一些建议，体验好了不少。目前国内比较火的快时尚品牌有JINS(睛姿)、LOHO眼镜生活、木九十、ZOFF(佐芙)、Aojo(艾镜)、EXE镜自由、eGG、URAKU(乐顾)、Zele、LookOptical等。 在小红书和什么值得买上，Jins可以说是众人的心头好，具体购买帖自己去搜，不在累述。定位年轻和高性价比的标签深得我心，所以就选它家的眼镜了，先是打算网购，但是没有办法试戴让我这个脸形不好撘的人知难而退。一搜发现成都的店面还真不太少，大概有七八家，选了从图片上看店面最大的环球中心店。 环球中心巨无霸的体积着实让我这个处于半失明状态的人找了好一阵，到了店门口就发现和外面那些妖艳贱货果然不一样，和周围的时装大牌完美融为一体，温馨的装修和开放的镜架让一些不打算配镜的人都有进去逛逛的冲动。 最后在店员小姐姐的推荐下选了一个999的钛框，考虑到左眼500的度数,加300元上了1.67，搞活动再优惠一百，到手价1199.由于需要定制镜片，5-7天后才能取镜或者邮寄，开箱图待补 下面是重点，在近几年一些媒体的刻意引导下，消费者和商家之间的信息不对等被刻意放大，很多人都觉得“商家的嘴，骗人的鬼”，当然一些无良商家也对造成这样的局面功不可没，我还是相信世界上还是好人多，有些商家还是会很贴心地帮你选择商品的，如果你还是觉得不太保险，那么最好的办法就是消除问题的根源–信息不平等，如果你能够分辨出商家嘴里每个晦涩难懂的词语的意思，那再没人能够骗到你。 ","date":"2021-07-12","objectID":"/glass/:0:2","series":null,"tags":null,"title":"眼镜新鸟的经验谈","uri":"/glass/"},{"categories":null,"content":"1.56? 1.60? 1.67？ 眼镜是通过折射改变入射光线，从而使外界的光线能够在视网膜上清晰成像，以达到矫正视力的目的。每人需要矫正的程度，或者说近视（远视）的度数不一样，通过改变镜片的形状或者折射率就可以实现不同的矫正度数。而商家在选择镜片时所说的1.56\\1.67就是指的镜片折射率，一般来说，折射率越高，镜片就越薄，随之重量下降和美观度也会提升。但对于低度数的同学来说，不同折射率之间的镜片薄厚差距微乎其微，而价格之间的差距就比较大了。高折射率的优势只有在高倍镜中才能体现出来。 1、100度以下的近视或平光，或者100度以下的远视，建议选择1.50折射率的镜片； 2、100~300度的近视，或者100~300度以下的远视，建议选择1.56折射率的镜片； 3、300~600度的近视，或者300度~600度以下的远视，建议选择1.60折射率的镜片； 4、600~800度的近视，建议选择1.67折射率的镜片； 5、800度以上的近视，建议选择1.74折射率的镜片。 ","date":"2021-07-12","objectID":"/glass/:0:3","series":null,"tags":null,"title":"眼镜新鸟的经验谈","uri":"/glass/"},{"categories":null,"content":"阿贝数？ 可能有的同学会想，我有钱，任性，虽然我度数不高，但是我就要选最贵的1.74折射率，那减少的零点几克重量对本仙女很重要。这样选择并不理智，这就涉及到一个商家往往不会告诉你的参数–阿贝数（色散系数）。 先来复习一下高中物理—同种介质对不同波长的光有不同的折射率。通过这个原理，我们可以造出三棱镜，将不同波长的光分开，衡量这种能力的指标就是阿贝数，色散现象在眼镜中同样存在，一些高度近视的朋友在通过眼镜边缘看物体时有时会发现物体边缘有蓝边，这就是发生了色散。色散程度越低，成像的效果越好，不同折射率的眼镜阿贝数参考如下 总体来说，1.50折射率的镜片的阿贝数可以达到58，但是一旦用到1.74折射率超超薄以上等级的镜片时，阿贝数会下降到32~36。所以，有好就有坏。如果一味追求镜片的薄，那么就会牺牲镜片的阿贝数，也就是降低了视觉对于颜色的真实感受，以及舒适度。 ","date":"2021-07-12","objectID":"/glass/:0:4","series":null,"tags":null,"title":"眼镜新鸟的经验谈","uri":"/glass/"}]